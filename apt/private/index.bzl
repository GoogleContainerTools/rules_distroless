"apt-get"

load(":lockfile.bzl", "lockfile")
load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")

_DEB_IMPORT_TMPL = '''\
    http_archive(
        name = "{name}",
        urls = {urls},
        sha256 = "{sha256}",
        build_file_content = """\
filegroup(
    name = "data",
    visibility = ["//visibility:public"],
    srcs = glob(["data.tar.*"]),
)

filegroup(
    name = "control",
    visibility = ["//visibility:public"],
    srcs = glob(["control.tar.*"]),
)
"""
    )
'''

_PACKAGE_TMPL = '''\

load("@rules_distroless//distroless:defs.bzl", "flatten")

# TODO: https://github.com/bazel-contrib/rules_oci/pull/523
flatten(
    name = "data",
    tars = [{src}],
    compress = "gzip",
    visibility = ["//visibility:public"],
)

alias(
    name = "control",
    actual = "@{repo_name}//:control",
    visibility = ["//visibility:public"],
)

filegroup(
    name = "{target_name}",
    visibility = ["//visibility:public"],
    srcs = [
        {deps}
    ] + [":data"]
)
'''

def _deb_package_index_impl(rctx):
    # Get the package name with either bzlmod enabled or disabled
    package_name = rctx.attr.name.split("~")[-1]

    package_defs = [
        '"""Generated by rules_distroless. DO NOT EDIT."""',
        """load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")""",
        "",
        "",
        "# buildifier: disable=function-docstring",
        "def {}_packages():".format(package_name),
    ]

    lockf = lockfile.from_json(rctx, rctx.attr.lock)

    if len(lockf.packages()) < 1:
        package_defs.append("   pass")

    for (package) in lockf.packages():
        package_key = lockfile.make_package_key(
            package["name"],
            package["version"],
            package["arch"],
        )

        package_defs.append(
            _DEB_IMPORT_TMPL.format(
                name = "%s_%s" % (rctx.attr.name, package_key),
                package_name = package["name"],
                urls = [package["url"]],
                sha256 = package["sha256"],
            ),
        )

        repo_name = "%s%s_%s" % ("@" if rctx.attr.bzlmod else "", rctx.attr.name, package_key)

        rctx.file(
            "%s/%s/BUILD.bazel" % (package["name"], package["arch"]),
            rctx.attr.package_template.format(
                target_name = package["arch"],
                src = '"@%s//:data"' % repo_name,
                deps = ",\n        ".join([
                    '"//%s/%s"' % (dep["name"], package["arch"])
                    for dep in package["dependencies"]
                ]),
                urls = [package["url"]],
                name = package["name"],
                arch = package["arch"],
                sha256 = package["sha256"],
                repo_name = "%s" % repo_name,
            ),
        )

    rctx.file("packages.bzl", "\n".join(package_defs))
    rctx.file("BUILD.bazel", """
alias(
    name = "lock",
    actual = "@{}{}_resolution//:lock",
    tags = ["manual"],
)
exports_files(glob(['packages.bzl']))
""".format("@" if rctx.attr.bzlmod else "", rctx.attr.name))

deb_package_index = repository_rule(
    implementation = _deb_package_index_impl,
    attrs = {
        "lock": attr.label(),
        "package_template": attr.string(default = _PACKAGE_TMPL),
        "bzlmod": attr.bool(default = False),
    },
)

def deb_package_index_bzlmod(
        module_ctx,
        name,
        lock,
        package_template = _PACKAGE_TMPL):
    """A macro to do everything that `deb_package_index` does, but for bzlmod.

    Args:
        module_ctx: the module context
        name: the name of the repository
        lock: label to a `lock.json`
        package_template: (EXPERIMENTAL!) a template string for generated BUILD files.
          Available template replacement keys are: `{target_name}`, `{deps}`, `{urls}`, `{name}`, `{arch}`, `{sha256}`, `{repo_name}`
    """

    lockf = lockfile.from_json(module_ctx, lock)

    if len(lockf.packages()) < 1:
        return

    for (package) in lockf.packages():
        package_key = lockfile.make_package_key(
            package["name"],
            package["version"],
            package["arch"],
        )

        repo_name = "%s_%s" % (name, package_key)

        http_archive(
            name = repo_name,
            urls = [
                package["url"],
            ],
            sha256 = package["sha256"],
            build_file_content = """\
filegroup(
    name = "data",
    visibility = ["//visibility:public"],
    srcs = glob(["data.tar.*"]),
)

filegroup(
    name = "control",
    visibility = ["//visibility:public"],
    srcs = glob(["control.tar.*"]),
)
""",
        )

        module_ctx.file(
            "%s/%s/BUILD.bazel" % (package["name"], package["arch"]),
            package_template.format(
                target_name = package["arch"],
                src = '"@@%s//:data"' % repo_name,
                deps = ",\n        ".join([
                    '"//%s/%s"' % (dep["name"], package["arch"])
                    for dep in package["dependencies"]
                ]),
                urls = [package["url"]],
                name = package["name"],
                arch = package["arch"],
                sha256 = package["sha256"],
                repo_name = "%s" % repo_name,
            ),
        )
