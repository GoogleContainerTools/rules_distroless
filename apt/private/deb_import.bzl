"deb_import"

load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
load(":starlark_codegen.bzl", "starlark")
load(":util.bzl", "util")

_DEB_IMPORT_BUILD_TMPL = '''
genrule(
    name = "data",
    srcs = glob(["data.tar*"]),
    outs = ["layer.tar.gz"],
    cmd = """
    # Per the dpkg-dev man page:
    # https://manpages.debian.org/bookworm/dpkg-dev/deb.5.en.html
    #
    # Debian data.tar files can be:
    #  - .tar uncompressed, supported since dpkg 1.10.24
    #  - .tar compressed with
    #    *  gzip: .gz
    #    * bzip2: .bz2, supported since dpkg 1.10.24
    #    *  lzma: .lzma, supported since dpkg 1.13.25
    #    *    xz: .xz, supported since dpkg 1.15.6
    #    *  zstd: .zst, supported since dpkg 1.21.18
    #
    # ZSTD_BIN can decompress all formats except bzip2
    #
    # The OCI image spec supports .tar and .tar compressed with gzip or zstd.
    # Bazel needs the output filename to be fixed in advanced so we settle for
    # gzip compression.

    data_file="$$(basename $<)"

    if [[ "$$data_file" == "data.tar.bz2" ]]; then
      # TODO: support bz2
      echo "ERROR: unsupported compression: bz2"
      exit 1
    elif [[ "$$data_file" == "data.tar.gz" ]]; then
      mv $< $@
    elif [[ "$$data_file" == "data.tar" ]]; then
      $(ZSTD_BIN) --compress --format=gzip $< >$@
    else
      $(ZSTD_BIN) --force --decompress --stdout $< |
      $(ZSTD_BIN) --compress --format=gzip - >$@
    fi
    """,
    toolchains = ["@zstd_toolchains//:resolved_toolchain"],
    visibility = ["//visibility:public"],
)

filegroup(
    name = "control",
    srcs = glob(["control.tar.*"]),
    visibility = ["//visibility:public"],
)
'''

def make_deb_import_key(repo_name, package):
    return "{}_{}_{}_{}".format(
        repo_name,
        util.sanitize(package.name),
        package.arch,
        util.sanitize(package.version),
    )

def deb_import(name, url, sha256, **kwargs):
    http_archive(
        name = name,
        url = url,
        sha256 = sha256,
        build_file_content = _DEB_IMPORT_BUILD_TMPL,
        **kwargs
    )

def _deb_import_tmpl(repo_name, package):
    deb_import_key = make_deb_import_key(repo_name, package)

    return '''\
    deb_import(
        name = "{name}",
        url = "{url}",
        sha256 = "{sha256}",
    )
'''.format(name = deb_import_key, url = package.url, sha256 = package.sha256)

def deb_packages(repo_name, packages):
    deb_imports = [
        _deb_import_tmpl(repo_name, package)
        for architectures in packages.values()
        for package in architectures.values()
    ]

    return '''\
"""Generated by rules_distroless. DO NOT EDIT."""
load("@rules_distroless//apt/private:deb_import.bzl", "deb_import")

# buildifier: disable=function-docstring
def {repo_name}_packages():
{deb_imports}
'''.format(
        repo_name = repo_name,
        deb_imports = "\n".join(deb_imports) if deb_imports else "    pass",
    )

def package_build(package, repo_prefix, repo_name, template):
    deb_import_key = make_deb_import_key(repo_name, package)

    pkg_repo_name = "@%s%s" % (repo_prefix, deb_import_key)

    alias_data = starlark.gen("%s//:data" % pkg_repo_name)
    alias_control = starlark.gen("%s//:control" % pkg_repo_name)

    deps = [
        "//%s/%s" % (dep.name, package.arch)
        for dep in package.dependencies
    ]
    deps = starlark.gen(deps, indent_count = 1)

    return template.format(
        target_name = package.arch,
        src = '"@%s%s//:data"' % (repo_prefix, deb_import_key),
        deps = deps,
        urls = [package.url],
        name = package.name,
        arch = package.arch,
        sha256 = package.sha256,
        repo_name = pkg_repo_name,
        alias_data = alias_data,
        alias_control = alias_control,
    )
