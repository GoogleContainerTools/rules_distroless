"apt extensions"

load("@bazel_features//:features.bzl", "bazel_features")
load("//apt/private:deb_import.bzl", "deb_import")
load("//apt/private:deb_resolve.bzl", "deb_resolve", "internal_resolve")
load("//apt/private:deb_translate_lock.bzl", "deb_translate_lock")
load("//apt/private:lockfile.bzl", "lockfile")

def _distroless_extension(module_ctx):
    root_direct_deps = []
    root_direct_dev_deps = []
    reproducible = False

    for mod in module_ctx.modules:
        for install in mod.tags.install:
            lockf = None
            if not install.lock:
                lockf = internal_resolve(
                    module_ctx,
                    "yq",
                    install.manifest,
                    install.resolve_transitive,
                )

                if not install.nolock:
                    # buildifier: disable=print
                    print("\nNo lockfile was given, please run `bazel run @%s//:lock` to create the lockfile." % install.name)
            else:
                if module_ctx.path(install.lock).exists:
                    lockf = lockfile.from_json(module_ctx, module_ctx.read(install.lock))
                else:
                    # buildifier: disable=print
                    print("\nSpecified lockfile '%s' not found. An empty lockfile is assumed." % install.lock)
                    lockf = lockfile.from_json(module_ctx, None)
                reproducible = True

            for (package) in lockf.packages():
                package_key = lockfile.make_package_key(
                    package["name"],
                    package["version"],
                    package["arch"],
                )

                deb_import(
                    name = "%s_%s" % (install.name, package_key),
                    urls = package["urls"],
                    sha256 = package["sha256"],
                    mergedusr = install.mergedusr,
                )

            deb_resolve(
                name = install.name + "_resolve",
                manifest = install.manifest,
                resolve_transitive = install.resolve_transitive,
            )

            deb_translate_lock(
                name = install.name,
                lock = install.lock,
                lock_content = lockf.as_json(),
                package_template = install.package_template,
            )

            if mod.is_root:
                if module_ctx.is_dev_dependency(install):
                    root_direct_dev_deps.append(install.name)
                else:
                    root_direct_deps.append(install.name)

    metadata_kwargs = {}
    if bazel_features.external_deps.extension_metadata_has_reproducible:
        metadata_kwargs["reproducible"] = reproducible

    return module_ctx.extension_metadata(
        root_module_direct_deps = root_direct_deps,
        root_module_direct_dev_deps = root_direct_dev_deps,
        **metadata_kwargs
    )

_install_doc = """
Module extension to create Debian repositories.

Create Debian repositories with packages "installed" in them and available
to use in Bazel.


Here's an example how to create a Debian repo:

```starlark
apt = use_extension("@rules_distroless//apt:extensions.bzl", "apt")
apt.install(
    name = "bullseye",
    lock = "//examples/apt:bullseye.lock.json",
    manifest = "//examples/apt:bullseye.yaml",
)
use_repo(apt, "bullseye")
```

Note that, for the initial setup (or if we want to run without a lock) the
lockfile attribute can be omitted. All you need is a YAML
[manifest](/examples/debian_snapshot/bullseye.yaml):
```yaml
version: 1

sources:
  - channel: bullseye main
    url: https://snapshot-cloudflare.debian.org/archive/debian/20240210T223313Z

archs:
  - amd64

packages:
  - perl
```

`apt.install` will parse the manifest and will fetch and install the packages
for the given architectures in the Bazel repo `@<NAME>`.

Each `<PACKAGE>/<ARCH>` has two targets that match the usual structure of a
Debian package: `data` and `control`.

You can use the package like so: `@<REPO>//<PACKAGE>/<ARCH>:<TARGET>`.

E.g. for the previous example, you could use `@bullseye//perl/amd64:data`.

### Lockfiles

As mentioned, the macro can be used without a lock because the lock will be
generated internally on-demand. However, this comes with the cost of
performing a new package resolution on repository cache misses.

The lockfile can be generated by running `bazel run @bullseye//:lock`. This
will generate a `.lock.json` file of the same name and in the same path as
the YAML `manifest` file.

If you explicitly want to run without a lock and avoid the warning messages
set the `nolock` argument to `True`.

### Best Practice: use snapshot archive URLs

While we strongly encourage users to check in the generated lockfile, it's
not always possible because Debian repositories are rolling by default.
Therefore, a lockfile generated today might not work later if the upstream
repository removes or publishes a new version of a package.

To avoid this problems and increase the reproducibility it's recommended to
avoid using normal Debian mirrors and use snapshot archives instead.

Snapshot archives provide a way to access Debian package mirrors at a point
in time. Basically, it's a "wayback machine" that allows access to (almost)
all past and current packages based on dates and version numbers.

Debian has had snapshot archives for [10+
years](https://lists.debian.org/debian-announce/2010/msg00002.html). Ubuntu
began providing a similar service recently and has packages available since
March 1st 2023.

To use this services simply use a snapshot URL in the manifest. Here's two
examples showing how to do this for Debian and Ubuntu:
  * [/examples/debian_snapshot](/examples/debian_snapshot)
  * [/examples/ubuntu_snapshot](/examples/ubuntu_snapshot)

For more infomation, please check https://snapshot.debian.org and/or
https://snapshot.ubuntu.com.
"""

install = tag_class(
    attrs = {
        "name": attr.string(
            doc = "Name of the generated repository",
            mandatory = True,
        ),
        "manifest": attr.label(
            doc = "The file used to generate the lock file",
            mandatory = True,
        ),
        "lock": attr.label(
            doc = "The lock file to use for the index.",
        ),
        "nolock": attr.bool(
            doc = "If you explicitly want to run without a lock, set it " +
                  "to `True` to avoid the DEBUG messages.",
            default = False,
        ),
        "package_template": attr.label(
            doc = "(EXPERIMENTAL!) a template file for generated BUILD " +
                  "files.",
        ),
        "resolve_transitive": attr.bool(
            doc = "Whether dependencies of dependencies should be " +
                  "resolved and added to the lockfile.",
            default = True,
        ),
        "mergedusr": attr.bool(
            doc = "Whether packges should be normalized following mergedusr conventions.\n" +
                  "Turning this on might fix the following error thrown by docker for ambigious paths: `duplicate of paths are supported.` \n" +
                  "For more context please see https://salsa.debian.org/md/usrmerge/-/raw/master/debian/README.Debian?ref_type=heads",
            default = False,
        ),
    },
    doc = _install_doc,
)

apt = module_extension(
    implementation = _distroless_extension,
    tag_classes = {
        "install": install,
    },
)
