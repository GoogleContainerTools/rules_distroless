"apt-get"

load("//apt/private:index.bzl", _deb_package_index = "deb_package_index")
load("//apt/private:resolve.bzl", _deb_resolve = "deb_resolve")

def deb_index(
        name,
        manifest,
        lock = None,
        package_template = None,
        resolve_transitive = True):
    """A convience repository macro for apt rules.

    This documentation provides an overview of the convenience repository macro around `package_index` and `resolve` repository rules.

    ### WORKSPACE Example

    ```starlark
    load("@rules_distroless//apt:index.bzl", "deb_index")

    deb_index(
        name = "bullseye",
        # For the initial setup, the lockfile attribute can be omitted and generated by running
        #    bazel run @bullseye//:lock
        # This will generate the lock.json file next to the manifest file by replacing `.yaml` with `.lock.json`
        lock = "//examples/apt:bullseye.lock.json",
        manifest = "//examples/apt:bullseye.yaml",
    )

    load("@bullseye//:packages.bzl", "bullseye_packages")
    bullseye_packages()
    ```

    ### BZLMOD Example

    ```starlark
    apt = use_extension("@rules_distroless//apt:extensions.bzl", "apt")
    apt.deb_index(
        name = "bullseye",
        lock = "//examples/apt:bullseye.lock.json",
        manifest = "//examples/apt:bullseye.yaml",
    )
    use_repo(apt, "bullseye")
    ```

    ### Macro Expansion

    This macro will expand to two repositories: `#name` and `#name#_resolve`.

    ### Typical Workflow

    A typical workflow for `deb_index` involves the generation of a lockfile (`deb_resolve`) and the consumption of the lockfile by `deb_package_index` for generating a DAG.

    #### Lockfile Generation

    The lockfile generation can be on-demand by omitting the `lock` attribute. However, this comes with the cost of performing a new package resolution on repository cache misses.

    While we strongly encourage users to check in the generated lockfile, it's not always possible because Debian repositories are rolling by default. Therefore, a lockfile generated today might not work later if the upstream repository removes or publishes a new version of a package.

    #### Snapshot repositories

    ##### Debian
    Users can still use a `snapshot` repository and check in the generated lockfiles. This is possible because `snapshot.debian.org` is an immutable point-in-time snapshot of the upstream repositories, meaning packages never get deleted or updated in a specific snapshot.

    An example of this can be found at [/examples/debian_snapshot](/examples/debian_snapshot).

    ##### Ubuntu
    Ubuntu also has a similar point-in-time snapshot service hosted at `snapshot.ubuntu.com`, which can be used similarly.

    An example of this can be found at [/examples/ubuntu_snapshot](/examples/ubuntu_snapshot).

    Args:
        name: name of the repository
        manifest: label to a `manifest.yaml`
        lock: label to a `lock.json`
        package_template: (EXPERIMENTAL!) a template string for generated BUILD files.
          Available template replacement keys are: `{target_name}`, `{deps}`, `{urls}`, `{name}`, `{arch}`, `{sha256}`, `{repo_name}`
        resolve_transitive: whether dependencies of dependencies should be resolved and added to the lockfile.
    """
    _deb_resolve(
        name = name + "_resolution",
        manifest = manifest,
        resolve_transitive = resolve_transitive,
    )

    if not lock:
        # buildifier: disable=print
        print("\nNo lockfile was given, please run `bazel run @%s//:lock` to create the lockfile." % name)

    _deb_package_index(
        name = name,
        manifest = manifest,
        lock = lock if lock else "@" + name + "_resolution//:lock.json",
        package_template = package_template,
    )
