"apt-get"

load("//apt/private:index.bzl", _deb_package_index = "deb_package_index")
load("//apt/private:resolve.bzl", _deb_resolve = "deb_resolve")

def deb_index(
        name,
        manifest,
        lock = None,
        package_template = None,
        resolve_transitive = True):
    """A convience repository macro around package_index and resolve repository rules.

    WORKSPACE example;

    ```starlark
    load("@rules_distroless//apt:index.bzl", "deb_index")

    deb_index(
        name = "bullseye",
        # For the initial setup, the lockfile attribute can be omitted  and generated by running
        #    bazel run @bullseye//:lock
        # This will generate the lock.json file next to the manifest file by replacing `.yaml` with `.lock.json`
        lock = "//examples/apt:bullseye.lock.json",
        manifest = "//examples/apt:bullseye.yaml",
    )

    load("@bullseye//:packages.bzl", "bullseye_packages")
    bullseye_packages()
    ```

    BZLMOD example;
    ```starlark
    # TODO: support BZLMOD
    ```

    This macro will expand to two repositories;  `<name>` and `<name>_resolve`.

    A typical workflow for `deb_index` involves generation of a lockfile `deb_resolve`
    and consumption of lockfile by `deb_package_index` for generating a DAG.

    The lockfile generation can be `on-demand` by omitting the lock attribute, however,
    this comes with the cost of doing a new package resolution on repository cache misses.

    While we strongly encourage users to check in the generated lockfile, it's not always
    possible to check in the generated lockfile as by default Debian repositories are rolling,
    therefore a lockfile generated today might not work work tomorrow  as the upstream
    repository might publish new version of a package.

    That said, users can still use a `debian archive snapshot` repository and check-in the
    generated lockfiles. This is possible because by design `debian snapshot` repositories
    are immutable point-in-time snapshot of the upstream repositories, which means packages
    never get deleted or updated in a specific snapshot.

    An example of this could be found [here](/examples/apt).

    Args:
        name: name of the repository
        manifest: label to a `manifest.yaml`
        lock: label to a `lock.json`
        package_template: (EXPERIMENTAL!) a template string for generated BUILD files.
          Available template replacement keys are: `{target_name}`, `{deps}`, `{urls}`, `{name}`, `{arch}`, `{sha256}`, `{repo_name}`
        resolve_transitive: whether dependencies of dependencies should be resolved and added to the lockfile.
    """
    _deb_resolve(
        name = name + "_resolution",
        manifest = manifest,
        resolve_transitive = resolve_transitive,
    )

    if not lock:
        # buildifier: disable=print
        print("\nNo lockfile was given, please run `bazel run @%s//:lock` to create the lockfile." % name)

    _deb_package_index(
        name = name,
        lock = lock if lock else "@" + name + "_resolution//:lock.json",
        package_template = package_template,
    )
