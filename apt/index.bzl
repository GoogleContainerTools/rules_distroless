"apt-get"

load("//apt/private:index.bzl", _deb_package_index = "deb_package_index")
load("//apt/private:resolve.bzl", _deb_resolve = "deb_resolve")

def deb_index(
        name,
        manifest,
        lock = None,
        package_template = None,
        resolve_transitive = True):
    """A convience repository macro around package_index and resolve repository rules.

    WORKSPACE example;

    ```starlark
    load("@rules_distroless//apt:index.bzl", "deb_index")

    deb_index(
        name = "bullseye",
        # For the initial setup, the lockfile attribute can be omitted  and generated by running
        #    bazel run @bullseye//:lock
        # This will generate the lock.json file next to the manifest file by replacing `.yaml` with `.lock.json`
        lock = "//examples/apt:bullseye.lock.json",
        manifest = "//examples/apt:bullseye.yaml",
    )

    load("@bullseye//:packages.bzl", "bullseye_packages")
    bullseye_packages()
    ```

    BZLMOD example;
    ```starlark
    # TODO: support BZLMOD
    ```

    This macro will expand to two repositories;  `<name>` and `<name>_resolve`.

    A typical workflow for `deb_index` involves generation of a lockfile `deb_resolve`
    and consumption of lockfile by `deb_package_index` for generating a DAG.

    The lockfile generation can be `on-demand` by omitting the lock attribute, however,
    this comes with the cost of doing a new package resolution on repository cache misses.

    While we strongly encourage users to check in the generated lockfile, it's not always
    possible to check in the generated lockfile as by default Debian repositories are rolling,
    therefore a lockfile generated today might not work later if the upstream repository
    removes or publishes a new version of a package.

    However, users can still use a `debian archive snapshot` repository and check-in the
    generated lockfiles. This is possible because by design since `snapshot.debian.org`
    repository is an immutable point-in-time snapshot of the upstream repositories which
    means packages that packages never get deleted or updated in a specific snapshot.

    An example of this could be found at [/examples/debian_snapshot](/examples/debian_snapshot).

    Ubuntu also has a similar point-in-time snapshot service hosted at `snapshot.ubuntu.com`
    which can be used in similarly.

    For an example of this can be found at [/examples/ubuntu_snapshot](/examples/ubuntu_snapshot).

    Args:
        name: name of the repository
        manifest: label to a `manifest.yaml`
        lock: label to a `lock.json`
        package_template: (EXPERIMENTAL!) a template string for generated BUILD files.
          Available template replacement keys are: `{target_name}`, `{deps}`, `{urls}`, `{name}`, `{arch}`, `{sha256}`, `{repo_name}`
        resolve_transitive: whether dependencies of dependencies should be resolved and added to the lockfile.
    """
    _deb_resolve(
        name = name + "_resolution",
        manifest = manifest,
        resolve_transitive = resolve_transitive,
    )

    if not lock:
        # buildifier: disable=print
        print("\nNo lockfile was given, please run `bazel run @%s//:lock` to create the lockfile." % name)

    _deb_package_index(
        name = name,
        lock = lock if lock else "@" + name + "_resolution//:lock.json",
        package_template = package_template,
    )
